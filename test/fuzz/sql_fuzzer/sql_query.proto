/*
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright 2022, Tarantool AUTHORS, please see AUTHORS file.
 */

syntax = "proto2";

package sql_query;

message SQLQuery {
    oneof query_oneof {
        Select select = 1;
        CreateTable create_table = 2;
    }
}

/* ~~~~SELECT~~~~ */

message Select {
    enum SelectOptionEnum {
        DISTINCT = 0;
        ALL = 1;
        NONE = 2;
    }
    required SelectOptionEnum option = 1;
    required SelectColumn column = 2;
    repeated SelectColumn extra_columns = 3;
    required SelectFromClause from_clause = 4;
    required bool from_clause_present_flag = 5;
    optional SelectWhereExpression where_expr = 6;
    optional SelectGroupByExpression group_by_exr = 7;
    optional SelectHavingExpression having_expr = 8;
    optional OrderBy order_by = 9;
    optional Limit limit = 10;
}

message SelectWhereExpression {
    required PredicateExpression expr = 1;
}

message SelectGroupByExpression {
    required FunctionExpression expr = 1;
}

message SelectHavingExpression {
    required PredicateExpression expr = 1;
}

message SelectColumn {
    oneof column_oneof {
        TableName any_column_from_table = 1;
        ColumnAsExpression select_column_expression = 2;
    }
    required ColumnAny any_fallback = 3;
}

message ColumnAny {
    /* Intentionally empty */
}

message ColumnAsExpression {
    required FunctionExpression expression = 1;
    optional ColumnName column_name = 2;
}

message SelectFromClause {
    oneof select_from_clause_oneof {
        SelectFromClauseOption1 option1 = 1;
        SelectFromClauseOption2 option2 = 2;
    }
    required JoinSource join_source_fallback = 3;
}

message SelectFromClauseOption1 {
    required TableName table_name = 1;
    optional TableName as_table_name = 2;
    enum SelectFromClauseOption1Enum {
        NOT_INDEXED = 0;
    }
    oneof indexed_oneof {
        SelectFromClauseOption1Enum indexed_enum = 3;
        IndexName index_name = 4;
    }
    /* If indexed_oneof is empty, nothing should be added, so there is no
     * fallback option.
     */
}

message SelectFromClauseOption2 {
    required Select select_statement = 1;
    optional TableName table_name = 2;
    required bool as_construction_present_flag = 3;
}

message JoinSource {
    oneof join_source_oneof {
        JoinedTable joined_table = 1;
    }
    required TableName table_name_fallback = 2;
}

message JoinedTable {
    required JoinSource left_join_source = 1;
    required JoinOperator join_operator = 2;
    required JoinSource right_join_source = 3;
    optional JoinSpecification specification = 4;
}

message LeftJoin {
    required bool natural = 1;
    required bool outer = 2;
}

message InnerJoin {
    required bool natural = 1;
}

message JoinOperator {
    oneof join_operator_oneof {
        LeftJoin left_join = 1;
        InnerJoin inner_join = 2;
    }
    /* Defalut value is CROSS JOIN */
}

message JoinSpecification {
    oneof join_specification_oneof {
        JoinSpecificationUsing using_specification = 1;
    }
    required JoinSpecificationOnExpression on_expr = 2;
}

message JoinSpecificationUsing {
    required ColumnName column_name = 1;
    repeated ColumnName extra_column_names = 2;
}

message JoinSpecificationOnExpression {
    required PredicateExpression expr = 1;
}

message IndexName {
    required uint32 code = 1;
}

/* There is a simplification -- instead of complex expression, there is just
 * ColumnName.
 */
message OrderBy {
    required OrderByExpression expr = 1;
    repeated OrderByExpression extra_exprs = 2;
}

message OrderByExpression {
    required ColumnName column_name = 1;
    enum OrderByExpressionEnum {
        ASCENDING = 0;
        DESCENDING = 1;
        NONE = 2;
    }
    required OrderByExpressionEnum order = 2;
}

message Limit {
    required int32 limit = 1;
    optional int32 offset = 2;
    enum OffsetEnum {
        OFFSET = 0;
        COMMA = 1;
    }
    required OffsetEnum offset_symbol_enum = 3;
}

/* ~~~~CREATE TABLE~~~~ */

message CreateTable {
    required bool if_not_exists = 1;
    required TableName table_name = 2;
    required DummyColumnDefinition dummy_definition = 3;
    repeated CreateTableOption options = 4;
    optional Engine engine = 5;
}

message TableName {
    required uint32 code = 1;
}

/* First column definition only with PRIMARY KEY constraint since Tarantool
 * does not accept tables without primary key.
 */
message DummyColumnDefinition {
    required DataType type = 1;
}

message CreateTableOption {
    oneof option_oneof {
        ColumnDefinition column_definition = 1;
        TableConstraint table_constraint = 2;
    }
    required ColumnDefinition column_definition_fallback = 3;
}

message ColumnDefinition {
    required ColumnName column_name = 1;
    required DataType type = 2;
    repeated ColumnConstraint constraints = 3;
}

message ColumnName {
    required uint32 code = 1;
}

message DataType {
    enum SpecialDataTypeEnum {
        ANY = 0;
        ARRAY = 1;
        MAP = 2;
    }
    enum DataTypeEnum {
        BOOLEAN = 0; /* same as BOOL */
        DECIMAL = 1;
        DOUBLE = 2;
        INTEGER = 3; /* same as INT */
        NUMBER = 4;
        UNSIGNED = 5;
        UUID = 6;
        VARBINARY = 7;
    }
    oneof data_type_oneof {
        SpecialDataTypeEnum special_type_enum = 1;
        DataTypeEnum type_enum = 2;
        CollatableDataType collatable_type = 3;
    }
    required DataTypeEnum type_enum_fallback = 4;
}

message CollatableDataType {
    enum CollatableDataTypeEnum {
        SCALAR = 0;
        STRING = 1;
        TEXT = 2;
    }
    oneof collatable_data_type_oneof {
        CollatableDataTypeEnum type_enum = 1;
        VarChar varchar = 2;
    }
    required CollatableDataTypeEnum type_enum_fallback = 3;
    optional CollationClause collation_clause = 4;
}

message VarChar {
    required uint32 integer = 1;
}

message CollationClause {
    enum CollationClauseEnum {
        none = 0;
        unicode = 1;
        unicode_ci = 2;
        binary = 3;
        unicode_sv_s1 = 4;
        /* TODO: tarantool/test/box/ddl_collation.result or
         * tarantool/test/sql-tap/collation.test.lua
         * Not sure if they should all be here or only these options.
         */
    }
    required CollationClauseEnum collation_clause_enum = 1;
}

message ColumnConstraint {
    oneof column_constraint_oneof {
        ColumnConstraintNullable nullable = 1;
        NamedColumnConstraint named_constraint = 2;
    }
    required DefaultExpression default_expression = 3;
}

message ColumnConstraintName {
    required uint32 code = 1;
}

message ColumnConstraintNullable {
    enum ColumnConstraintNullableEnum {
        NOT_NULL = 0;
        NULLABLE = 1;
    }
    required ColumnConstraintNullableEnum nullable_enum = 1;
}

message NamedColumnConstraint {
    optional ColumnConstraintName constraint_name = 1;
    oneof constraint_oneof {
        NamedColumnConstraintPrimaryKey primary_key = 2;
        ReferenceForeignKeyClause foreign_key_clause = 3;
        NamedColumnConstraintCheck check_expression = 4;
    }
    required NamedColumnConstraintUnique unique_fallback = 5;
}

message NamedColumnConstraintCheck {
    required PredicateExpression check_expression = 1;
}

message NamedColumnConstraintPrimaryKey {
    /* Intentionally empty */
}

message NamedColumnConstraintUnique {
    /* Intentionally empty */
}

message PredicateExpression {
    oneof predicate_oneof {
        CompareExpression compare = 1;
    }
    required bool bool_constant_fallback = 2;
}

message CompareExpression {
    enum ComporatorEnum {
        LESS = 0;
        LESS_EQUAL = 1;
        EQUAL = 2;
        NOT_EQUAL = 3; /* != */
        GREATER_EQUAL = 4;
        GREATER = 5;
        EQUAL_EQUAL = 6; /* == */
        DIFFERENT = 7; /* <> */
    }
    required Term left_operand = 1;
    required ComporatorEnum comporator = 2;
    required Term right_operand = 3;
}

message Term {
    oneof term_oneof {
        FunctionExpression func = 1;
        PredicateExpression predicate = 2;
        /* Instead of column name there may be anything other passed
         * in std::vector<std::string> to the ToString() function.
         */
        ColumnName column_name = 3;
    }
    required ConstantValue constant_fallback = 4;
}

message FunctionExpression {
    oneof function_expression_oneof {
        BinaryOperatorExpression binary_operator_expression = 1;
    }
    required UnaryOperatorExpression unary_operator_expression_fallback = 2;
}

message UnaryOperatorExpression {
    enum UnaryOperatorEnum {
        NOT = 0;
        PLUS = 1;
        MINUS = 2;
        IS_NULL = 3;
        IS_NOT_NULL = 4;
        NO_OPERATOR = 5;
    }
    required UnaryOperatorEnum unary_operator = 1;
    required Term term = 2;
}

message BinaryOperatorExpression {
    enum BinaryOperatorEnum {
        PLUS = 0;
        MINUS = 1;
        AND = 2;
        OR = 3;
        BINARY_AND = 4;
        BINARY_OR = 5;
        MULTIPLY = 6;
        DIVISION = 7;
        REMAINDER = 8;
        /* TODO: not implemented: << >> */
    }
    required Term left_operand = 1;
    required BinaryOperatorEnum binary_operator = 2;
    required Term right_operand = 3;
}

message ConstantValue {
    required uint64 value = 1;
    required DataType type = 2;
}

message ReferenceForeignKeyClause {
    required TableName table_name = 1;
    required ColumnName column_name = 2;
    repeated ColumnName extra_column_names = 3;
    required bool match_full = 4;

    optional ReferenceForeignKeyClauseRule delete_rule = 5;
    optional ReferenceForeignKeyClauseRule update_rule = 6;
}

message ReferenceForeignKeyClauseRule {
    enum ReferenceForeignKeyClauseRuleEnum {
        CASCADE = 0;
        SET_DEFAULT = 1;
        SET_NULL = 2;
        RESTRICT = 3;
        NO_ACTION = 4;
    }
    required ReferenceForeignKeyClauseRuleEnum rule = 1;
}

message DefaultExpression {
    required FunctionExpression expression = 1;
}

message TableConstraint {
    oneof table_constraint_oneof {
        /* Always produces errors because it's impossible to have two primary
         * keys and one already always defined in DummyColumnDefinition.
         */
        TableConstraintPrimaryKey primary_key = 1;
        TableConstraintCheck check_expression = 3;
        TableConstraintForeignKeyClause foreign_key = 4;
    }
    required TableConstraintUnique unique_fallback = 2;
}

message TableConstraintPrimaryKey {
    required ColumnName column_name = 1;
    repeated ColumnName extra_column_names = 2;
}

message TableConstraintUnique {
    required ColumnName column_name = 1;
    repeated ColumnName extra_column_names = 2;
}

message TableConstraintCheck {
    required PredicateExpression predicate = 1;
}

message TableConstraintForeignKeyClause {
    required ColumnName column_name = 1;
    repeated ColumnName extra_column_names = 2;
    required ReferenceForeignKeyClause reference = 3;
}

message Engine {
    enum EngineEnum {
        vinyl = 0;
        memtx = 1;
    }
    required EngineEnum engine_enum = 1;
}
